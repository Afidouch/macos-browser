//
//  BWEncryption.swift
//
//  Copyright Â© 2023 DuckDuckGo. All rights reserved.
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//  http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
//

import Foundation
import CommonCrypto
import OpenSSL
import os.log

final class BWEncryption {

    /// Returns public key base64 encoded
    func generateKeys() -> String? {
        let bignum = BN_new()
        BN_set_word(bignum, Const.pubExp)

        keypair = RSA_new()
        guard RSA_generate_key_ex(keypair, Const.keyLength, bignum, nil) != 0 else {
            return nil
        }

        // Return the public key in the desired format
        let output = BIO_new(BIO_s_mem())
        guard i2d_RSA_PUBKEY_bio(output, keypair) != 0 else {
            return nil
        }

        let outputLength = BIO_ctrl_pending(output)
        var outputKey = [UInt8].init(repeating: 0, count: outputLength + 1)
        _ = outputKey.withUnsafeMutableBytes { pointer in
            BIO_read(output, pointer.baseAddress, Int32(outputLength))
        }

        let outputData = Data(bytes: outputKey, count: outputLength)

        return outputData.base64EncodedString()
    }

    /// Set shared key from previous session
    @discardableResult
    func setSharedKey(_ sharedKey: Data) -> Bool {
        guard sharedKey.count == Const.sharedKeySize else {
            return false
        }

        sharedKeyData = sharedKey

        // First 32 bytes are encryption/decryption key
        encryptionKeyData = sharedKeyData?.subdata(in: 0..<32)
        _ = encryptionKeyData?.withUnsafeBytes({ pointer in
            AES_set_encrypt_key(pointer.baseAddress, Int32(32 * 8), &encryptionKey)
            AES_set_decrypt_key(pointer.baseAddress, Int32(32 * 8), &decryptionKey)
        })

        macKeyData = sharedKeyData?.subdata(in: 32..<64)
        return true
    }

    /// Decrypts shared key using the private key generated by previous method
    func decryptSharedKey(_ encryptedSharedKey: String) -> String? {
        // Make sure key pair is generated
        guard keypair != nil else {
            return nil
        }
        clearKeyData()

        guard let encryptedSharedKeyData = Data(base64Encoded: encryptedSharedKey) else {
            return nil
        }

        // Decrypt the shared key
        var encryptedSharedKeyDataPointer: [UInt8] = Array(encryptedSharedKeyData)
        var decryptedDataArray: [UInt8] = .init(repeating: 0, count: 2560)
        let decryptedLength = RSA_private_decrypt(RSA_size(keypair),
                                                  &encryptedSharedKeyDataPointer,
                                                  &decryptedDataArray,
                                                  keypair,
                                                  RSA_PKCS1_OAEP_PADDING)

        guard decryptedLength != -1 else {
            os_log(.default, "OpenSSLWrapper: Decryption of the shared key failed %s", ERR_error_string(ERR_get_error(), nil))
            return nil
        }

        let sharedKeyData = Data(decryptedDataArray[0..<Int(decryptedLength)])
        // Hold for further communication
        setSharedKey(sharedKeyData)

        // Return to store for future sessions
        return sharedKeyData.base64EncodedString()
    }

    /// Encrypts data using the shared key decrypted in previous method
    func encryptData(_ data: Data) -> BWEncryptionOutput? {
        guard macKeyData != nil else {
            return nil
        }

        guard let ivData = generateIv() else {
            return nil
        }

        let dataArray: [UInt8] = Array(data)
        let dataArrayLength = dataArray.count

        // AES has a fixed block size of 16-bytes regardless key size
        let encryptedDataLength = Int(ceil(Double(dataArrayLength) / Double(Const.blockSize))) * Const.blockSize
        var encryptionOutput: [UInt8] = .init(repeating: 0, count: encryptedDataLength)

        var ivCopy: [UInt8] = Array(ivData)

        // Encrypt
        encryptionOutput.withUnsafeMutableBufferPointer { encryptionOutputPointer in
            ivCopy.withUnsafeMutableBufferPointer { ivCopyPointer in
                AES_cbc_encrypt(dataArray, encryptionOutputPointer.baseAddress, dataArrayLength, &encryptionKey, ivCopyPointer.baseAddress, AES_ENCRYPT)
            }
        }

        let encryptedData = Data(bytes: encryptionOutput, count: encryptedDataLength)

        // Compute HMAC
        guard let hmacData = computeHmac(for: encryptedData, withIV: ivData) else {
            return nil
        }

        // Wrap into EncryptionOutput structure
        return BWEncryptionOutput(iv: ivData, data: encryptedData, hmac: hmacData)
    }

    /// Decrypts data using the shared key
    func decryptData(_ data: Data, withIV ivData: Data) -> Data {
        // AES has a fixed block size of 16-bytes regardless of the key size
        let decryptionOutputLength = Int((Double(data.count) / Double(Const.blockSize) + 1) * Double(Const.blockSize))
        var decryptionOutput: [UInt8] = .init(repeating: 0, count: decryptionOutputLength)

        var ivCopy: [UInt8] = Array(ivData)
        var dataBytes = Array(data)

        // Decrypt
        dataBytes.withUnsafeMutableBytes { dataBytesPointer in
            ivCopy.withUnsafeMutableBufferPointer { ivCopyPointer in
                decryptionOutput.withUnsafeMutableBufferPointer { decryptionOutputPointer in
                    AES_cbc_encrypt(dataBytesPointer.baseAddress, decryptionOutputPointer.baseAddress, data.count, &decryptionKey, ivCopyPointer.baseAddress, AES_DECRYPT)
                }
            }
        }

        // Padding removal
        var outputLength = decryptionOutputLength
        while isgraph(Int32(decryptionOutput[outputLength - 1])) == 0 {
            outputLength -= 1
        }

        let decryptedData = Data(decryptionOutput[0..<outputLength])

        return decryptedData
    }

    /// Computes Hmac used for comparison after receiving of messages
    func computeHmac(for data: Data, withIV ivData: Data) -> Data? {
        guard macKeyData?.isEmpty == false else {
            return nil
        }

        var macData = ivData + data
        var cHMAC = [UInt8].init(repeating: 0, count: Int(CC_SHA256_DIGEST_LENGTH))

        let macKeyDataCount = macKeyData?.count ?? 0
        let macDataCount = macData.count

        macData.withUnsafeMutableBytes { macDataPointer in
            macKeyData?.withUnsafeMutableBytes { macKeyDataPointer in
                cHMAC.withUnsafeMutableBytes { cHMACPointer in
                    CCHmac(
                        UInt32(kCCHmacAlgSHA256),
                        macKeyDataPointer.baseAddress,
                        macKeyDataCount,
                        macDataPointer.baseAddress,
                        macDataCount,
                        cHMACPointer.baseAddress
                    )
                }
            }
        }

        return Data(cHMAC)
    }

    /// Cleans public, private and shared key
    func cleanKeys() {
        RSA_free(keypair)
        keypair = nil
        clearKeyData()
    }

    // MARK: - Private

    // Key pair is used for encryption(public key - server) and decryption(private key - client) of the shared key
    private var keypair: OpaquePointer?

    // Shared key is received from Bitwarden
    // First half (32 bytes) is used for encryption/decryption of messages
    // Second half (32 bytes) for hmac
    private var sharedKeyData: Data?

    private var encryptionKeyData: Data?

    private var encryptionKey = AES_KEY()
    private var decryptionKey = AES_KEY()
    private var macKeyData: Data?

    deinit {
        RSA_free(keypair)
    }

    private func clearKeyData() {
        sharedKeyData = nil
        encryptionKeyData = nil
        macKeyData = nil
    }

    private func generateIv() -> Data? {
        var iv = [UInt8].init(repeating: 0, count: Const.ivLength)
        let returnCode: Int32 = iv.withUnsafeMutableBytes { pointer in
            guard let baseAddress = pointer.baseAddress else {
                return 1
            }
            return SecRandomCopyBytes(kSecRandomDefault, Const.ivLength, baseAddress)
        }
        guard returnCode == 0 else {
            return nil
        }
        return Data(iv)
    }

    enum Const {
        static let keyLength: Int32 = 2048
        static let pubExp: UInt = 65537
        static let ivLength: Int = 16
        static let blockSize: Int = 16
        static let sharedKeySize: Int = 64
    }
}
